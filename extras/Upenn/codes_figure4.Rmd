---
title: "Codes to output plots and results for Figure 4 of the article"
output:
  pdf_document: default
  html_document: default
date: "2022-12-09"
---
```{r}
library(pda)
library(EvidenceSynthesis)
library(ggplot2)
library(Cyclops)
library(dplyr)
# setwd("/Users/qwu1221/Dropbox/Projects/QuadApprox/singleCox/sim1207")
source('load_functions_figure4.R')
```

# Simulate data: use site 2,4,9,6 as an example
```{r}
# set.seed(1)
# settings <- EvidenceSynthesis::createSimulationSettings(nSites = 10,
#                                                         n = round(runif(10, 1000, 2000)),
#                                                         minBackgroundHazard = 0.00001,
#                                                         maxBackgroundHazard = 0.0001,
#                                                         treatedFraction = 0.5,
#                                                         hazardRatio = 0.5,
#                                                         randomEffectSd = 0,
#                                                         nStrata = 1)
# populations <- EvidenceSynthesis::simulatePopulations(settings)
# 
# populations <- lapply(c(2,4,9,6), function(x) populations[[x]])

folder <- "D:/SmallCountMetaAnalysis/Example"
exampleId <- 2
examples <- readr::read_csv(file.path(folder, "Examples.csv"), show_col_types = FALSE)
example <- examples %>%
  filter(exampleId == !!exampleId)
dbs <- c("CCAE", "MDCR", "MDCD","Optum")
populations <- lapply(dbs, function(x) readRDS(file.path(folder, sprintf("StratPop_%s_%d.rds", x, exampleId))))
  
```

# Plots of local likelihood
```{r}
getLocalPlotData <- function(x, InputData){
  ll <- rep(0)
  for (i in 1:length(x)) {
    ll[i] <- GetLocalDeriv(InputBeta = x[i], InputData = InputData)[1]
  }
  ll <- ll - max(ll)
  return(data.frame(hr = exp(x),ll=ll)) # hazard ratio
}

bounds <- c(log(0.02), log(8))
x <- seq(bounds[1], bounds[2], length.out = 200)
site.names <- c("CCAE", "MDCR", "MDCD","Optum")
plot.data <- lapply(1:4, function(i) cbind(getLocalPlotData(x=x, populations[[i]]), site = site.names[i]))
plot.data <- do.call(rbind,plot.data)
plot.data$site = factor(plot.data$site, levels = c("CCAE", "MDCR", "MDCD","Optum"))
p1 <- plotLocalLik(plot.data)
#ggsave(plot, file="localLik.png", width=4, height=8, bg = "white")

```


```{r fig.asp = 2.5, fig.width = 4.2}
p1 
```


# Initialization using meta-analysis
```{r}
fitModelInDatabase <- function(population) {
   cyclopsData <- Cyclops::createCyclopsData(Surv(time, y) ~ x + strata(stratumId), data = population, modelType = "cox")
   cyclopsFit <- Cyclops::fitCyclopsModel(cyclopsData)
   if(cyclopsFit$return_flag=="ILLCONDITIONED"){
    mode <- NA
    lb <- NA
    ub <- NA
  }else{
    mode <- coef(cyclopsFit)
    ci95 <- confint(cyclopsFit, 1, level = 0.95)
    lb <- ci95[2]
    ub <- ci95[3]
  }
    return(list(mode,lb,ub))
  }
data <- lapply(populations, fitModelInDatabase)
data <- as.matrix(do.call("rbind", data))
  # initialization using local estimates
LocalFit <- unlist(data[,1])
LocalCI <- data[,2:3]
AggSite <- which(rowSums(is.na(LocalCI))==0)  # only use sites with finite se
AggSE <- (unlist(LocalCI[AggSite,2])-unlist(LocalCI[AggSite,1]))/(2 * qnorm(0.975))
AggFit <- LocalFit[AggSite]
InputBeta <- sum(AggFit/AggSE^2)/sum(1/AggSE^2)
InputBeta
```

# Output local and global derivatives 
```{r}
Derivs<-lapply(populations, GetLocalDeriv,InputBeta=InputBeta)
Derivs<-do.call("rbind", Derivs)
rownames(Derivs) <- site.names
Derivs # local derivatives
colSums(Derivs) # global derivatives
```

# Output comparison plot on global likelihood: Pade, quadratic, true

```{r}
# Pade function
PadeCoef<-GetGlobalPadeCoef(InputBeta,populations)
padeFunction<-function(beta){  # bbar is the initial point, beta is the point you'd like to evaluate
    x <- beta-InputBeta
    Pm<- cbind(1,x,x^2)%*%PadeCoef$num_coef
    Qn <- cbind(1,x,x^2)%*%PadeCoef$denom_coef
    pade <- Pm/Qn
    return(pade)
}
# Quadratic function
c0 <- colSums(Derivs)[1]
c1 <- colSums(Derivs)[2]
c2 <- colSums(Derivs)[3]/2

Taylor2Function <- function(x){
  x <- x-InputBeta
  taylor <- (c0+c1*x+c2*x^2)
  return(taylor)
}
# Pool data
InputData <- do.call(rbind,populations)

# plot data
ll <- rep(0)
y.pade <- rep(0)
y.taylor <- rep(0)
for (i in 1:200) {
  y.pade[i] <- padeFunction(x[i])
  y.taylor[i] <- Taylor2Function(x[i])
  ll[i] <- GetLocalDeriv(InputBeta = x[i], InputData = InputData)[1]
}
ll <- ll - max(ll)
y.pade <- y.pade - max(y.pade)
y.taylor <- y.taylor - max(y.taylor)

plot.data2 = rbind(data.frame(x = exp(x), ll = y.pade, method = "Padé"), 
                   data.frame(x = exp(x), ll = ll, method ="True"), 
                  data.frame(x = exp(x), ll = y.taylor, method = "Quadratic"))
plot.data2$method = factor(plot.data2$method, levels = c("True", "Quadratic", "Padé"))
p2 <- plotGlobalLik.comparison(plot.data2)
```

```{r fig.asp = 1.1, fig.width = 3.6}
p2
```

# Save data for these two plots (then I'll be able to make changes in the future, thank you so much!)
```{r}
saveRDS(list(plot.data,plot.data2), file="figure4_PlotData.rds")
```

